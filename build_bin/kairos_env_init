#!/bin/bash -xe

# make sure to avoid recursion in the startup files
# this makes it so the invoked subshells below
unset BASH_ENV
export BASH_ENV

# make sure to avoid recursion in the startup files
# this makes it so the invoked subshells below
export BASH_ENV=/opt/kairos/bin/script_init

# NOTE: this script must be sourced, not run directly.
#       It is designed to munge the environment for
#       builds, placing super-secret-squirrel
#       credentials in the right place.

# set this to 1 see verbose output
_KAIROS_VERBOSE=${_KAIROS_VERBOSE:-0}

output() {
  if [ "${_KAIROS_VERBOSE}" -ne 0 ]; then
    echo $*
  else
    /bin/true
  fi
}

# A function to be installed as the error handler (call script_init to install)
error_hook() {
  echo "source: ${BASH_SOURCE[@]}"
  echo "lines:  ${BASH_LINENO[@]}"
  echo "funcs:  ${FUNCS[@]}"
  echo "at ${BASH_SOURCE[1]}:${BASH_LINENO[0]}"
}

# setups up the error handling in a script
script_init() {
  trap error_hook ERR
}

# shortcut to exit with error and error message.
# Invoke with: error_exit <rc> <message>
#
# Note: this will not invoke the error handler
error_exit() {
  RC=$1
  MESSAGE=$2
  ERROR_SOURCE=${BASH_SOURCE[1]}:${BASH_LINENO[0]}
  echo "$MESSAGE (from $ERROR_SOURCE)" 1>&2
  exit $RC
}

export -f error_hook
export -f script_init
export -f error_exit


. ${KAIROS_VENV}/bin/activate

export LC_ALL=C.UTF-8
export LANG=C.UTF-8

check_env () {
  if [ -z "${!1}" ]; then
    echo "No ${1} defined!" 1>&2
    exit 1
  fi
  return 0
}

check_env AWS_SECRET_ACCESS_KEY
check_env AWS_ACCESS_KEY_ID

export AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION:-us-west-2}

SECRET_SET_NAME=${SECRET_SET_NAME:-default-build-secrets}
CREDSTASH_TABLE=${CREDSTASH_TABLE:-circleci-secrets}

if [ ! -f ~/.kairos-credentials ]; then
  echo "Downloading secrets via credstash"
  credstash -t ${CREDSTASH_TABLE} get ${SECRET_SET_NAME} > ~/.kairos-credentials
else
  output "Found cached secrets"
fi

# pull the secrets out of a { "name": "value" } JSON object and
# export them into our environment.
output "Publishing secrets as environment variables"

eval $(jq -r 'to_entries | .[] | "export " + .key+ "=\"" + .value + "\""' \
        < ~/.kairos-credentials)


if [ ! -f $VIRTUAL_ENV/pip.conf ]; then
  echo "Wiring virtualenv"
  # pure side effect
  (wire_virtualenv)
else
  output "Found wired virtualenv"
fi

if [ ! -f /opt/kairos/etc/pypirc ]; then
  echo "Wiring package publishing config"
  # set up publishing default
  cat - > /opt/kairos/etc/pypirc <<EOF
[distutils]
index-servers = artifactory-python3

[artifactory-python3]
username = ${KAIROS_PUBLISH_USER}
repository = https://${KAIROS_PYPI_PUBLISH_URL}
EOF
fi

if [ ! -f maps-key.txt ]; then
  if [ ! -z "${KAIROS_MAPS_KEY}" ]; then
    echo ${KAIROS_MAPS_KEY} >> maps-key.txt
    output "Wrote map key to maps-key.txt"
  else
    echo "No maps key available."
  fi
fi

if [ -f .circleci/kairos-lambda.json ]; then
  # pull in lambda config
  eval $(jq -r 'to_entries | .[] | "export " + .key+ "=\"" + .value + "\""' \
          < .circleci/kairos-lambda.json)
fi

# make sure certain directories exist
mkdir -p logs
