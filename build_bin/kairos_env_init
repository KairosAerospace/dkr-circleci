#!/bin/bash -e

# NOTE: this script must be sourced, not run directly.
#       It is designed to munge the environment for
#       builds, placing super-secret-squirrel
#       credentials in the right place.

# A function to be installed as the error handler (call script_init to install)
error_hook() {
  error_source=${BASH_SOURCE[1]}:${BASH_LINENO[0]}
  echo "Error at: ${error_source}" 1>&2
}

# setups up the error handling in a script
script_init() {
  trap error_hook ERR
}

# shortcut to exit with error and error message.
# Invoke with: error_exit <rc> <message>
#
# Note: this will not invoke the error handler
error_exit() {
  RC=$1
  MESSAGE=$2
  ERROR_SOURCE=${BASH_SOURCE[1]}:${BASH_LINENO[0]}
  echo "$MESSAGE (from $ERROR_SOURCE)" 1>&2
  exit $RC
}

. ${KAIROS_VENV}/bin/activate

check_env () {
  if [ -z "${!1}" ]; then
    echo "No ${1} defined!" 1>&2
    exit 1
  fi
  return 0
}

check_env AWS_SECRET_ACCESS_KEY
check_env AWS_ACCESS_KEY_ID
check_env AWS_DEFAULT_REGION

SECRET_SET_NAME=${SECRET_SET_NAME:-default-build-secrets}
CREDSTASH_TABLE=${CREDSTASH_TABLE:-circleci-secrets}

if [ ! -f .credentials ]; then
  echo "Downloading secrets via credstash"
  credstash -t ${CREDSTASH_TABLE} get ${SECRET_SET_NAME} > .credentials
else
  echo "Found cached secrets"
fi

# pull the secrets out of a { "name": "value" } JSON object and
# export them into our environment.
echo "Publishing secrets as environment variables"
eval $(jq -r 'to_entries | .[] | "export " + .key+ "=\"" + .value + "\""' \
        < .credentials)


if [ ! -f $VIRTUAL_ENV/pip.conf ]; then
  echo "Wiring virtualenv"
  # pure side effect
  (wire_virtualenv)
else
  echo "Found wired virtualenv"
fi

if [ ! -f /opt/kairos/etc/pypirc ]; then
  echo "Wiring package publishing config"
  # set up publishing default
  cat - > /opt/kairos/etc/pypirc <<EOF
[distutils]
index-servers = artifactory-python3

[artifactory-python3]
username = ${KAIROS_PUBLISH_USER}
repository = https://${KAIROS_PYPI_PUBLISH_URL}
EOF
fi

if [ ! -f maps-key.txt ]; then
  if [ ! -z "${KAIROS_MAPS_KEY}" ]; then
    echo ${KAIROS_MAPS_KEY} >> maps-key.txt
    echo "Wrote map key to maps-key.txt"
  else
    echo "No maps key available."
  fi
fi

if [ -f .circleci/kairos-lambda.json ]; then
  # pull in lambda config
  eval $(jq -r 'to_entries | .[] | "export " + .key+ "=\"" + .value + "\""' \
          < .circleci/kairos-lambda.json)
fi

# make sure certain directories exist
mkdir -p logs
